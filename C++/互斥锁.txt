互斥锁实际的效率还是可以让人接受的，加锁的时间大概100ns左右，而实际上互斥锁的一种可能的实现是先自旋一段时间，当自旋的时间超过阀值之后再将线程投入睡眠中，因此在并发运算中使用互斥锁(每次占用锁的时间很短)的效果可能不亚于使用自旋锁。

互斥锁是一种信号量

信号量(Semaphore)，有时被称为信号灯，是在多线程环境下使用的一种设施, 它负责协调各个线程, 以保证它们能够正确、合理的使用公共资源。 

1、“饥饿状态”：这个互斥量一直没有被解锁，等待锁定它的线程将一直被挂着，即它请求某个资源，但永远得不到它。用户必须在程序中努力避免这种“饥饿”状态出现。Pthread函数库不会自动处理这种情况。

2、“死锁”：一组线程中的所有线程都在等待被同组中另外一些线程占用的资源，这时，所有线程都因等待互斥量而被挂起，它们中的任何一个都不可能恢复运行，程序无法继续运行下去。这时就产生了死锁。Pthread函数库可以跟踪这种情形，最后一个线程试图调用pthread_mutex_lock()时会失败，并返回类型为EDEADLK的错误。

互斥锁属性：

1、普通锁 当一个线程加锁以后，其余请求锁的线程将形成一个等待队列，并在解锁后按优先级获得锁。这种锁策略保证了资源分配的公平性。

2、嵌套锁，允许同一个线程对同一个锁成功获得多次，并通过多次unlock解锁。如果是不同线程请求，则在加锁线程解锁时重新竞争。

3、检错锁，如果同一个线程请求同一个锁，则返回EDEADLK（出现死锁），否则与PTHREAD_MUTEX_TIMED_NP类型（普通锁）动作相同。这样就保证当不允许多次加锁时不会出现最简单情况下的死锁。

4、适应锁，动作最简单的锁类型，仅等待解锁后重新竞争。 

锁操作：

    锁操作主要包括加锁pthread_mutex_lock()、解锁pthread_mutex_unlock()和测试加锁 pthread_mutex_trylock()三个，不论哪种类型的锁，都不可能被两个不同的线程同时得到，而必须等待解锁。对于普通锁和适应锁类型，解锁者可以是同进程内任何线程;而检错锁则必须由加锁者解锁才有效，否则返回EPERM;对于嵌套锁，文档和实现要求必须由加锁者解锁，但实验结果表明并没有这种限制，这个不同还没有得到解释。在同一进程中的线程，如果加锁后没有解锁，则任何其他线程都无法再获得锁。


初始化互斥锁           pthread_mutex_init            //内存必须清零  成功返回值为0

使互斥锁保持一致       pthread_mutex_consistent_np

锁定互斥锁             pthread_mutex_lock

解除锁定互斥锁         pthread_mutex_unlock

使用非阻塞互斥锁锁定   pthread_mutex_trylock

销毁互斥锁             pthread_mutex_destroy 