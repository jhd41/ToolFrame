使用命名空间的目的是对标识符的名称进行本地化，以避免命名冲突。在C++中，变量、函数和类都是大量存在

的。如果没有命名空间，这些变量、函数、类的名称将都存在于全局命名空间中，会导致很多冲突。比如，如

果我们在自己的程序中定义了一个函数toupper()，这将重写标准库中的toupper()函 数，这是因为这两个函数

都是位于全局命名空间中的。

std命名空间
标准C++把自己的整个库定义在std命名空间中。这就是本书的大部分程序都有下面代码的原因：
using namespace std;
这样写是为了把std命名空间的成员都引入到当前的命名空间中，以便我们可以直接使用其中的函数和类，而不用每次都写上std::。
当然，我们是可以显示地在每次使用其中成员的时候都指定std::，只要我们喜欢。例如，我们可以显示地采用如下语句指定cout：
std::cout << “显示使用std::来指定cout”;
如果我们的程序中只是少量地使用了std命名空间中的成员，或者是引入std命名空间可能导致命名空间的冲突的话，我们就没有必要使用using namespace std;了。然而，如果在程序中我们要多次使用std命名空间的成员，则采用using namespace std;的方式把std命名空间的成员都引入到当前命名空间中会显得方便很多，而不用每次都单独在使用的时候显示指定.


由于namespace的概念，使用C++标准程序库的任何标识符时，可以有三种选择:

1、直接指定标识符。例如std::ostream而不是ostream。完整语句如下: std::cout << std::hex << 3.4 << std::endl;

2、使用using关键字。 using std::cout; using std::endl; using std::cin; 以上程序可以写成 cout << std::hex << 3.4 << endl;

3、最方便的就是使用using namespace std; 例如: using namespace std;这样命名空间std内定义的所有标识符都有效(曝光)。就好像它们被声明为全局变量一样。那么以上语句可以如下写: cout <<hex << 3.4 << endl;因为标准库非常的庞大，所以程序员在选择的类的名称或函数名时就很有可能和标准库中的某个名字相同。所以为了避免这种情况所造成的名字冲突，就把标准库中的一切都被放在名字空间std中。但这又会带来了一个新问题。无数原有的C++代码都依赖于使用了多年的伪标准库中的功能，他们都是在全局空间下的。所以就有了<iostream.h>和<iostream>等等这样的头文件，一个是为了兼容以前的C++代码，一个是为了支持新的标准。命名空间std封装的是标准程序库的名称，标准程序库为了和以前的头文件区别，一般不加".h"


作用域解析运算符（：：）

当程序中 不能用namespace关键字的时候，那么我们可以用using 关键字来进行比方using std::cout;